:javascript
  //Accepts a JSON string that is a flat array of statues or a JSON representation of another graph
  function UCDRibbonGraph(data, data_format, filter){
    this.nodes = [];  //nested
    this.links = [];  //flat
    this.filter = filter;

    this.time_1 = null;
    this.time_2 = null;
    this.starting_cohort_count = null;
    this.not_specified_count = 0;

    this.data = data;
    this.data_format = data_format;

    if (this.data_format == "json-individual"){
      this.create_graph_from_individual_json(this.data);
    } else if (this.data_format == "json-aggregate"){

    } else if (this.data_format == "csv-aggregate"){
      this.create_graph_from_aggregate_csv(this.data);
    }
  }

  UCDRibbonGraph.prototype = {
    find_node_recursive : function(name, type, time){
      var existing_node = this.find_toplevel_node(name[0], type[0], time);

      if (existing_node){
        if (name.length > 1){
          return existing_node.find_subnode_recursive(name.slice(1), type.slice(1), time);
        }

        return existing_node;
      }

      return null;
    },

    find_toplevel_node : function(name, type, time){
      for(var i = 0, len = this.nodes.length; i < len; i++) {
        if (this.nodes[i].name === name
             && this.nodes[i].time === time
             && this.nodes[i].type === type){
          return this.nodes[i];
        }
      }
      return null;
    },

    find_link : function(src_node, tgt_node){
      for(var i = 0, len = this.links.length; i < len; i++) {
        if (this.links[i].source === src_node && this.links[i].target === tgt_node)
          return this.links[i];
      }
      return null;
    },

    create_top_level_node : function(name, type, time){
      var new_node = new UCDRibbonGraphNode(name,type,time,null,this);
      this.nodes.push(new_node);
      return new_node;
    },

    //name and type params are arrays describing the name and type of each node from the top level down to the leaf.  Time is the same for all.
    create_leaf_node : function(name, type, time){
      var existing_node = this.find_toplevel_node(name[0], type[0], time);

      if (existing_node){
        existing_node.value++;
        if (name.length > 1){
          existing_node.add_or_increment_subnode(name.slice(1), type.slice(1), time);
        }

        return existing_node;
      } else {
        var new_node = new UCDRibbonGraphNode(name[0], type[0], time, null, this);
        new_node.value++;
        new_node.showing = true;
        if (name.length > 1){
          new_node.add_or_increment_subnode(name.slice(1), type.slice(1), time);
        }
        this.nodes.push(new_node);

        return new_node;
      }

    },

    create_link : function(src_node, tgt_node){
      var existing_link = this.find_link(src_node, tgt_node);

      if (existing_link == null){
        var new_link = new UCDRibbonGraphLink(src_node, tgt_node);
        this.links.push(new_link);
        return new_link;
      } else {
        existing_link.value++;
      }
      return null;
    },

    create_or_increment_link_and_parent_node_links : function(src_node, tgt_node){
      var source = src_node;
      while (source != null){
        var target = tgt_node;
        while(target != null){
          var new_link = this.create_link(source,target);
          if (new_link != null){
            source.sourceLinks.push(new_link);
            target.targetLinks.push(new_link);
          }
          target = target.parent_node;
        }
        source = source.parent_node;
      }
    },

    get_total_students_in_graph : function(){
      var time = this.nodes[0].time;
      var total = 0;
      this.nodes.forEach(function(n){
        if (n.time == time){
          total += n.value;
        }
      });

      return total;
    },

    update_link_showing : function(){
      this.links.forEach(function(l){
        if (l.source.is_showing() && l.target.is_showing()
            && l.is_nonzero())
          l.showing = true;
        else
          l.showing = false;
      });
    },

    to_json : function(){
      return JSON.stringify(this);
    },

    // Converts to the format required by d3.sankey.  Takes the nested node array and flattens it based on what nodes are expanded and non-zero.
    // Only includes links that are connected to a non-zero expanded node.
    to_sankey_object : function(){
      this.update_link_showing();

      var flat_object = {
          nodes : [],
          links : this.links.filter(this.is_nonzero).filter(this.is_showing)
      }

      var nonzero_toplevel_nodes = this.nodes.filter(this.is_nonzero);
      nonzero_toplevel_nodes.forEach(function(n){
        flat_object.nodes.push(n.get_object_or_children());
      });
      flat_object.nodes = this.flatten_array(flat_object.nodes);


      return flat_object;//JSON.stringify(this);
    },

    to_sankey_json : function(){
      return JSON.stringify(this.to_sankey_object);
    },

    is_showing : function(link_or_node){
      return link_or_node.showing;
    },

    is_selected : function(link_or_node){
      return link_or_node.selected;
    },

    is_nonzero : function(link_or_node){
      return link_or_node.value > 0;
    },

    create_graph_from_individual_json : function(data){
      var raw_data_total = data["STUDENTS"].length;
      var filtered_data = this.filter.filter_data(data);

      console.log("FILTERED DATA:");
      console.log(filtered_data);

      var graph = this;

      var time_1 = $("#time_1_select").val();
      var time_2 = $("#time_2_select").val();
      this.time_1 = time_1;
      this.time_2 = time_2;

      var starting_cohort = {
        "STUDENTS" : filtered_data["STUDENTS"].filter(function(student){
          return (student["RECORDS"][0]["TIME"]+"") == time_1;
        })
      }

      this.starting_cohort_count = starting_cohort["STUDENTS"].length;
      this.not_specified_count = 0;

      var nodes = {},
          links = {};

      //TEMPORARY remove after TEA
      if (#{current_user.institution.name == "UC Davis"})
        starting_cohort["STUDENTS"].forEach(function(student){
          student["RECORDS"].forEach(function(record){
            if (record["GROUPS"][2]["major"] == '0000')
              record["GROUPS"][1]["discipline"] = 'ACOLW';
          });
        });
      //END TEMPORARY

      starting_cohort["STUDENTS"].forEach(function(student){
        var time_1_record = student["RECORDS"][0];
        var time_2_record = student["RECORDS"].filter(function(r){ return (""+r["TIME"]) == time_2 })[0];

        if (time_1_record != undefined && time_2_record != undefined && time_1 != time_2){
          var time_1_group_types = time_1_record["GROUPS"].map(function(g){ return Object.keys(g)[0] });
          var time_1_group_vals = time_1_record["GROUPS"].map(function(g){ return g[Object.keys(g)[0]] });

          graph.create_leaf_node(
            time_1_group_vals,
            time_1_group_types,
            time_1
          );

          var time_2_group_types = time_2_record["GROUPS"].map(function(g){ return Object.keys(g)[0] });
          var time_2_group_vals = time_2_record["GROUPS"].map(function(g){ return g[Object.keys(g)[0]] });

          graph.create_leaf_node(
            time_2_group_vals,
            time_2_group_types,
            time_2
          );

          var source_node = graph.find_node_recursive(
            time_1_group_vals,
            time_1_group_types,
            time_1
          );

          var target_node = graph.find_node_recursive(
            time_2_group_vals,
            time_2_group_types,
            time_2
          );

          graph.create_or_increment_link_and_parent_node_links(source_node, target_node);
        } else if (time_2_record == undefined){
          graph.not_specified_count += 1;
        }

      });

      $("#vis_filter_desc").html(
        "<p>The raw data contains "+raw_data_total+" people.</p>\n"+
        "<p>The selected cohort includes "+this.starting_cohort_count+" people.</p>\n"+
        "<p>"+this.not_specified_count+" people had an unspecified status during "+time_2+".</p>\n"
      );

      this.update_link_showing();
    },

    create_graph_from_aggregate_csv : function(data){
      var graph = this;

      var time_2 = $("#time_2_select").val();
      this.time_2 = time_2;

      var nodes = {},
          links = {};

      var first_record = true;
      data.forEach(function(record){

        var time = record["TIME"];
        var group_types = null;
        var group_vals = null;

        if (first_record)
          this.time_1 = time;

        for(var i = 0; i < record["NUMBER"]; i++){
          graph.create_leaf_node(
            fr_group_vals,
            fr_group_types,
            fr_time
          );
        }

        graph.create_or_increment_link_and_parent_node_links(source_node, target_node);
      });

      this.update_link_showing();
    },

    end_of_nth_year_from_fall_term : function(term,n){
      return (Math.floor(term/100)+n)*100+3
    },

    reset_node_and_link_values : function(){
      this.links.forEach(function(l){
        l.reset_value();
      });
    },

    select_none : function(){
      this.nodes.forEach(function(n){
        n.set_selection(false);
      });
    },

    array_equal : function(a, b){
      var i = Math.max(a.length, b.length, 1);
      while(i-- >= 0 && a[i] === b[i]);
      return (i === -2);
    },

    /*
     * @name flatten_array
     * @description flattens multi-dimension array into one-dimension array
     * useful for manipulating function arguments like flattenArray(arguments)
     * @usage flattenArray(arr)
     * eg.
     * [1, 2]                => [1, 2]
     * [1, [[[[[[2]]]]]]]    => [1, 2]
     * [1,[2,3],[[[[4]]],5]] => [1, 2, 3, 4, 5]
     *
     * @param {arr} Array to flatten
     * @return {Array} Array, one-dimension array
     */
     flatten_array : function(arr){
      	var r = [];

        while (!this.array_equal(r, arr)) {
            r = arr;
            arr = [].concat.apply([], arr);
        }
        return arr;
     }
  }
