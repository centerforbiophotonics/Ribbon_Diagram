:javascript
  //Accepts a JSON string that is a flat array of statues or a JSON representation of another graph
  function UCDRibbonGraph(json){
    this.nodes = [];  //nested
    this.links = [];  //flat
    this.filter = null;


    this.json = json;

    if (this.json != null){
      console.log('json import');

      var object = JSON.parse(this.json);

      if (Array.isArray(object)){
        console.log('array');
      } else {
        this.create_graph_from_base_data(object);
      }
    }
  }

  UCDRibbonGraph.prototype = {
    find_node_recursive : function(name, type, time){
      var existing_node = this.find_toplevel_node(name[0], type[0], time);

      if (existing_node){
        if (name.length > 1){
          return existing_node.find_subnode_recursive(name.slice(1), type.slice(1), time);
        }

        return existing_node;
      }

      return null;
    },

    find_toplevel_node : function(name, type, time){
      for(var i = 0, len = this.nodes.length; i < len; i++) {
        if (this.nodes[i].name === name
             && this.nodes[i].time === time
             && this.nodes[i].type === type){
          return this.nodes[i];
        }
      }
      return null;
    },

    find_link : function(src_node, tgt_node){
      for(var i = 0, len = this.links.length; i < len; i++) {
        if (this.links[i].source === src_node && this.links[i].target === tgt_node)
          return this.links[i];
      }
      return null;
    },

    create_top_level_node : function(name, type, time){
      var new_node = new UCDRibbonGraphNode(name,type,time,null,this);
      this.nodes.push(new_node);
      return new_node;
    },

    //name and type params are arrays describing the name and type of each node from the top level down to the leaf.  Time is the same for all.
    create_leaf_node : function(name, type, time){
      var existing_node = this.find_toplevel_node(name[0], type[0], time);

      if (existing_node){
        existing_node.value++;
        if (name.length > 1){
          existing_node.add_or_increment_subnode(name.slice(1), type.slice(1), time);
        }

        return existing_node;
      } else {
        var new_node = new UCDRibbonGraphNode(name[0], type[0], time, null, this);
        new_node.value++;
        new_node.showing = true;
        if (name.length > 1){
          new_node.add_or_increment_subnode(name.slice(1), type.slice(1), time);
        }
        this.nodes.push(new_node);

        return new_node;
      }

    },

    create_link : function(src_node, tgt_node){
      var existing_link = this.find_link(src_node, tgt_node);

      if (existing_link == null){
        var new_link = new UCDRibbonGraphLink(src_node, tgt_node);
        this.links.push(new_link);
        return new_link;
      } else {
        existing_link.value++;
      }
      return null;
    },

    create_or_increment_link_and_parent_node_links : function(src_node, tgt_node){
      var source = src_node;
      while (source != null){
        var target = tgt_node;
        while(target != null){
          var new_link = this.create_link(source,target);
          if (new_link != null){
            source.sourceLinks.push(new_link);
            target.targetLinks.push(new_link);
          }
          target = target.parent_node;
        }
        source = source.parent_node;
      }
    },

    get_total_students_in_graph : function(){
      var time = this.nodes[0].time;
      var total = 0;
      this.nodes.forEach(function(n){
        if (n.time == time){
          total += n.value;
        }
      });

      return total;
    },

    update_link_showing : function(){
      this.links.forEach(function(l){
        if (l.source.is_showing() && l.target.is_showing()
            && l.is_nonzero())
          l.showing = true;
        else
          l.showing = false;
      });
    },

    to_json : function(){
      return JSON.stringify(this);
    },

    // Converts to the format required by d3.sankey.  Takes the nested node array and flattens it based on what nodes are expanded and non-zero.
    // Only includes links that are connected to a non-zero expanded node.
    to_sankey_object : function(){
      this.update_link_showing();

      var flat_object = {
          nodes : [],
          links : this.links.filter(this.is_nonzero).filter(this.is_showing)
      }

      var nonzero_toplevel_nodes = this.nodes.filter(this.is_nonzero);
      nonzero_toplevel_nodes.forEach(function(n){
        flat_object.nodes.push(n.get_object_or_children());
      });
      flat_object.nodes = flattenArray(flat_object.nodes);


      return flat_object;//JSON.stringify(this);
    },

    to_sankey_json : function(){
      return JSON.stringify(this.to_sankey_object);
    },

    is_showing : function(link_or_node){
      return link_or_node.showing;
    },

    is_selected : function(link_or_node){
      return link_or_node.selected;
    },

    is_nonzero : function(link_or_node){
      return link_or_node.value > 0;
    },

    filter_students : function(data){
      var included_students = [];

      var filter = {
        gender: $('select#gender').val(),
        admit_level: $('select#admit_level').val(),
        urm: $('input#urm').is(':checked'),
        ethnicities: $('select#ethn_code').val(),
        started_stem: $('select#started_in_stem').val(),
        international: $('select#international').val(),
        eop: $('select#eop').val(),
        busp: $('select#busp').val(),
        murps: $('select#murps').val(),
        regents_offered: $('select#regents_offered').val()
      }

      this.filter = filter;

      data.background.forEach(function(student){
        var push = true;

        if ($.inArray(student.gender, filter.gender) == -1){
          push = false;
        }

        if ($.inArray(student.admit_level, filter.admit_level) == -1){
          push = false;
        }

        if (filter.urm && (student.is_urm == false)){
          push = false;
        }

        if (filter.urm == false){
          if (student.ethn_desc == null)
            student.ethn_desc = "BLANK";

          if ($.inArray(student.ethn_desc, filter.ethnicities) == -1){
            push = false;
          }
        }

        if ((filter.started_stem == "Excluded" && student.any_first_term_major_is_stem ) ||
            (filter.started_stem == "Only" && (student.any_first_term_major_is_stem == false))
        ){
          push = false;
        }

        if ((filter.international == "Excluded" && student.started_international ) ||
            (filter.international == "Only" && (student.started_international == false))
        ){
          push = false;
        }

        if ((filter.eop == "Excluded" && student.is_eop ) ||
            (filter.eop == "Only" && (student.is_eop == false))
        ){
          push = false;
        }

        if ((filter.busp == "Excluded" && student.is_busp ) ||
            (filter.busp == "Only" && (student.is_busp == false))
        ){
          push = false;
        }

        if ((filter.murps == "Excluded" && student.is_murps == 1) ||
            (filter.murps == "Only" && (student.is_murps == 0))
        ){
          push = false;
        }

        if ((filter.regents_offered == "Excluded" && student.ro_times_offered > 0) ||
            (filter.regents_offered == "Only" && (student.ro_times_offered == 0))
        ){
          push = false;
        }

        if (push){
          included_students.push(student.pidm);
        }
      });

      return included_students;
    },

    create_graph_from_base_data : function(data){
      //Iterate through statuses and generate counts based on filters.
      var filtered_pidms = this.filter_students(data);

      var graph = this;

      $("#vis_filter_desc").html("(Filtered to "+filtered_pidms.length+" people)");

      var end_term = parseInt($("#end_term").val());

      var nodes = {},
          links = {};

      data.statuses.forEach(function(status){
        if (status.major_1 == '0000')
         status.disc_1 = 'ACOLW';
      });


      data.statuses.forEach(function(status){
        if (
          $.inArray(status.pidm, filtered_pidms) != -1
        ){
          if (status.term == status.first_fall_term){  //Time = Started UCD
            graph.create_leaf_node(
              [status.status, status.disc_1, status.major_1],
              ["Status","Discipline","Major"],
              status.first_fall_term
            );

          } else if (status.term == end_term){//graph.end_of_nth_year_from_fall_term(status.first_fall_term, end_term)){  // Time = Graduated UCD or End of Window
            graph.create_leaf_node(
              [status.status, status.disc_1, status.major_1],
              ["Status","Discipline","Major"],
              end_term//graph.end_of_nth_year_from_fall_term(status.first_fall_term, end_term)
            );
          }
        }
      });


      var student_first_term = null;
      var student_last_term = null;
      data.statuses.forEach(function(status){
        if (
          $.inArray(status.pidm, filtered_pidms) != -1
        ){
          if (status.term == status.first_fall_term){  //Relies on statuses being sorted by pidm and then term
            student_first_term = status;
          } else if (status.term == end_term){//graph.end_of_nth_year_from_fall_term(status.first_fall_term, end_term)){
            student_last_term = status;

            var source_node = graph.find_node_recursive(
              [student_first_term.status, student_first_term.disc_1, student_first_term.major_1],
              ["Status", "Discipline", "Major"],
              student_first_term.term
            );

            var target_node = graph.find_node_recursive(
              [student_last_term.status, student_last_term.disc_1, student_last_term.major_1],
              ["Status", "Discipline", "Major"],
              student_last_term.term
            );

            graph.create_or_increment_link_and_parent_node_links(source_node, target_node);


            student_first_term = null;
            student_last_term = null;
          }
        }
      });

      this.update_link_showing();
    },

    end_of_nth_year_from_fall_term : function(term,n){
      return (Math.floor(term/100)+n)*100+3
    },

    reset_node_and_link_values: function(){
      this.links.forEach(function(l){
        l.reset_value();
      });
    },

    select_none: function(){
      this.nodes.forEach(function(n){
        n.set_selection(false);
      });
    }


  }


  //Test code
  //var graph = null;
        //
        //var load = function(){
        //  $.get(
        //    "/major_in_outs.json",
        //
        //    $('#major_in_out_form').serialize(),
        //
        //    function(data){
        //      if (!data.error) {
        //        var data_string = JSON.stringify(data);
        //        graph = new UCDRibbonGraph(data_string);
        //      } else {
        //
        //      }
        //    },
        //    "json"
        //  )
        //};

  function arrayEqual(a, b) {
  	var i = Math.max(a.length, b.length, 1);
  	while(i-- >= 0 && a[i] === b[i]);
  	return (i === -2);
  }

  /*
   * @name flattenArray
   * @description flattens multi-dimension array into one-dimension array
   * useful for manipulating function arguments like flattenArray(arguments)
   * @usage flattenArray(arr)
   * eg.
   * [1, 2]                => [1, 2]
   * [1, [[[[[[2]]]]]]]    => [1, 2]
   * [1,[2,3],[[[[4]]],5]] => [1, 2, 3, 4, 5]
   *
   * @param {arr} Array to flatten
   * @return {Array} Array, one-dimension array
   */
  function flattenArray(arr) {
  	var r = [];

  	while (!arrayEqual(r, arr)) {
  		r = arr;
  		arr = [].concat.apply([], arr);
  	}
  	return arr;
  }

  //window.onload = load;